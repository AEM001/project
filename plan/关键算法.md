         
# 云算力资源租用系统 - 关键算法设计

基于之前的代码规划，以下是实现系统预期功能的关键算法设计，采用文字描述和伪代码相结合的方式。

## 一、用户模块关键算法

### 1. 用户登录验证算法

**功能描述**：验证用户登录信息，确保安全访问系统。

```cpp
// UserManager::login 方法实现
User* UserManager::login(string id, string password) {
    // 1. 查找用户
    User* user = getUserById(id);
    if (user == nullptr) {
        throw UserException(ERROR_USER_NOT_FOUND, "用户不存在");
    }
    
    // 2. 检查用户状态
    if (user->status != UserStatus::ACTIVE) {
        throw UserException(ERROR_USER_INACTIVE, "用户状态异常，无法登录");
    }
    
    // 3. 验证密码
    string encryptedPassword = Utils::encryptPassword(password);
    if (!user->verifyLogin(encryptedPassword)) {
        // 记录登录失败日志
        logManager.addLog("登录失败", id, "密码错误");
        throw UserException(ERROR_PASSWORD_INCORRECT, "密码错误");
    }
    
    // 4. 登录成功，记录日志
    logManager.addLog("用户登录", id, "登录成功");
    
    // 5. 检查未读通知
    vector<Notification> unreadNotifications = 
        notificationService.getNotifications(id, true);
    if (!unreadNotifications.empty()) {
        // 显示高优先级通知
        for (auto& notification : unreadNotifications) {
            if (notification.priority > 1) {
                cout << "重要通知: " << notification.content << endl;
            }
        }
    }
    
    return user;
}
```

### 2. 用户配额计算算法

**功能描述**：根据用户类型计算资源配额，实现差异化资源分配。

```cpp
// Student::calculateQuota 方法实现
int Student::calculateQuota() override {
    // 学生基础配额
    int baseQuota = 100;
    
    // 根据班级或其他因素调整配额
    if (className.find("研究生") != string::npos) {
        baseQuota *= 1.5;  // 研究生配额提升50%
    }
    
    // 确保不超过最大配额
    return min(baseQuota, maxQuota);
}

// Teacher::calculateQuota 方法实现
int Teacher::calculateQuota() override {
    // 教师基础配额，高于学生
    int baseQuota = 300;
    
    // 根据部门或职称调整配额
    if (department == "计算机科学" || department == "人工智能") {
        baseQuota *= 1.2;  // 特定部门配额提升20%
    }
    
    // 确保不超过最大配额
    return min(baseQuota, maxQuota);
}

// Administrator::calculateQuota 方法实现
int Administrator::calculateQuota() override {
    // 管理员配额，最高
    return 500 * permissionLevel;  // 根据权限等级计算
}
```

### 3. 密码加密算法

**功能描述**：保护用户密码安全，防止明文存储和传输。

```cpp
// Utils::encryptPassword 方法实现
string Utils::encryptPassword(string password) {
    // 使用SHA-256哈希算法
    string hashedPassword = "";
    
    // 添加盐值增强安全性
    string salt = "CloudResourceSystem";
    string saltedPassword = password + salt;
    
    // 计算哈希值
    unsigned char hash[32];
    // 实际实现中调用SHA256算法
    // SHA256((unsigned char*)saltedPassword.c_str(), saltedPassword.length(), hash);
    
    // 转换为十六进制字符串
    char hexString[65];
    for (int i = 0; i < 32; i++) {
        sprintf(hexString + i * 2, "%02x", hash[i]);
    }
    hexString[64] = '\0';
    
    hashedPassword = string(hexString);
    return hashedPassword;
}
```

## 二、资源管理模块关键算法

### 1. 资源查询与过滤算法

**功能描述**：根据用户需求筛选合适的资源，支持多条件查询。

```cpp
// ResourceManager::getFilteredResources 方法实现
vector<CloudResource*> ResourceManager::getFilteredResources(
    string type = "", 
    double maxPrice = -1, 
    int minCores = -1, 
    int minMemory = -1) {
    
    vector<CloudResource*> filteredResources;
    
    for (auto resource : resources) {
        // 跳过非可用资源
        if (resource->status != ResourceStatus::AVAILABLE) {
            continue;
        }
        
        // 类型过滤
        if (!type.empty() && resource->type != type) {
            continue;
        }
        
        // 价格过滤
        if (maxPrice > 0 && resource->basePrice > maxPrice) {
            continue;
        }
        
        // 根据资源类型进行特定过滤
        if (resource->type == "CPU") {
            CPUResource* cpuResource = dynamic_cast<CPUResource*>(resource);
            if (minCores > 0 && cpuResource->cores < minCores) {
                continue;
            }
        } else if (resource->type == "GPU") {
            GPUResource* gpuResource = dynamic_cast<GPUResource*>(resource);
            if (minMemory > 0 && gpuResource->memory < minMemory) {
                continue;
            }
        }
        
        // 通过所有过滤条件，添加到结果集
        filteredResources.push_back(resource);
    }
    
    // 按价格排序
    sort(filteredResources.begin(), filteredResources.end(), 
        [](CloudResource* a, CloudResource* b) {
            return a->basePrice < b->basePrice;
        });
    
    return filteredResources;
}
```

### 2. 资源价格计算算法

**功能描述**：根据资源类型和使用时长计算租用费用，实现差异化定价。

```cpp
// CPUResource::calculatePrice 方法实现
double CPUResource::calculatePrice(int hours) override {
    // 基础价格 × 核心数 × 时长 × 频率系数
    double frequencyFactor = frequency / 2.5;  // 2.5GHz为基准
    double price = basePrice * cores * hours * frequencyFactor;
    
    // 长时间使用折扣
    if (hours > 72) {
        price *= 0.9;  // 超过72小时打9折
    }
    if (hours > 168) {
        price *= 0.95;  // 超过一周再打95折
    }
    
    return price;
}

// GPUResource::calculatePrice 方法实现
double GPUResource::calculatePrice(int hours) override {
    // 基础价格 × 显存系数 × 时长 × 型号系数
    double memorySizeFactor = memory / 8.0;  // 8GB为基准
    double modelFactor = 1.0;
    
    // 根据型号调整系数
    if (model.find("RTX") != string::npos) {
        modelFactor = 1.5;
    } else if (model.find("Tesla") != string::npos) {
        modelFactor = 2.0;
    }
    
    double price = basePrice * memorySizeFactor * hours * modelFactor;
    
    // 长时间使用折扣
    if (hours > 48) {
        price *= 0.85;  // GPU长时间使用折扣更大
    }
    
    return price;
}

// StorageResource::calculatePrice 方法实现
double StorageResource::calculatePrice(int hours) override {
    // 基础价格 × 容量系数 × 时长 × 速度系数
    double capacityFactor = capacity / 100.0;  // 100GB为基准
    double speedFactor = readWriteSpeed / 100.0;  // 100MB/s为基准
    
    double price = basePrice * capacityFactor * hours * speedFactor;
    
    // 存储资源长期使用有更大折扣
    if (hours > 168) {
        price *= 0.7;  // 超过一周打7折
    }
    
    return price;
}
```

## 三、租用管理模块关键算法

### 1. 租用申请创建与验证算法

**功能描述**：创建租用申请并进行资格验证，确保符合系统规则。

```cpp
// RentalManager::createRental 方法实现
bool RentalManager::createRental(string userId, string resourceId, int hours) {
    // 1. 获取用户和资源
    User* user = userManager.getUserById(userId);
    CloudResource* resource = resourceManager.getResourceById(resourceId);
    
    if (user == nullptr || resource == nullptr) {
        throw ResourceException(ERROR_INVALID_PARAMS, "用户或资源不存在");
    }
    
    // 2. 检查资源状态
    if (resource->status != ResourceStatus::AVAILABLE) {
        throw ResourceException(ERROR_RESOURCE_UNAVAILABLE, "资源当前不可用");
    }
    
    // 3. 检查租用时长
    if (hours < 1 || hours > billingService.maxRentalTime) {
        throw ResourceException(ERROR_INVALID_RENTAL_TIME, 
            "租用时长必须在1-" + to_string(billingService.maxRentalTime) + "小时之间");
    }
    
    // 4. 检查用户配额
    int userQuota = user->calculateQuota();
    int requiredQuota = 0;
    
    // 根据资源类型计算所需配额
    if (resource->type == "CPU") {
        CPUResource* cpuResource = dynamic_cast<CPUResource*>(resource);
        requiredQuota = cpuResource->cores * hours / 24;  // 每核心每天消耗1点配额
    } else if (resource->type == "GPU") {
        GPUResource* gpuResource = dynamic_cast<GPUResource*>(resource);
        requiredQuota = gpuResource->memory * hours / 12;  // 每GB显存每12小时消耗1点配额
    } else {
        StorageResource* storageResource = dynamic_cast<StorageResource*>(resource);
        requiredQuota = storageResource->capacity * hours / 1000;  // 每TB每小时消耗1点配额
    }
    
    if (requiredQuota > userQuota) {
        throw ResourceException(ERROR_QUOTA_EXCEEDED, 
            "配额不足，需要" + to_string(requiredQuota) + "点，当前有" + to_string(userQuota) + "点");
    }
    
    // 5. 预估费用
    double estimatedFee = resource->calculatePrice(hours);
    
    // 6. 检查余额
    if (user->getBalance() < estimatedFee) {
        // 记录余额不足通知
        notificationService.addNotification(
            userId, 
            "余额不足，无法创建租用申请。当前余额: " + to_string(user->getBalance()) + 
            "，预估费用: " + to_string(estimatedFee),
            2  // 高优先级
        );
        throw UserException(ERROR_INSUFFICIENT_BALANCE, "余额不足，请充值");
    }
    
    // 7. 创建租用记录
    Rental rental;
    rental.rentalId = Utils::generateUniqueId();
    rental.userId = userId;
    rental.resourceId = resourceId;
    rental.startTime = 0;  // 审核通过后设置
    rental.endTime = 0;    // 审核通过后设置
    rental.fee = estimatedFee;
    rental.status = RentalStatus::PENDING;
    rental.reviewerId = "";
    rental.reviewTime = 0;
    rental.reviewComment = "";
    
    // 8. 添加到租用列表
    rentals.push_back(rental);
    
    // 9. 记录日志
    logManager.addLog("创建租用申请", userId, 
        "资源ID: " + resourceId + ", 时长: " + to_string(hours) + "小时");
    
    // 10. 通知管理员审核
    vector<User*> admins = userManager.getAdministrators();
    for (auto admin : admins) {
        notificationService.addNotification(
            admin->id,
            "新的租用申请等待审核，申请ID: " + rental.rentalId,
            1  // 中等优先级
        );
    }
    
    return true;
}
```

### 2. 租用审核算法

**功能描述**：管理员审核租用申请，决定通过或拒绝。

```cpp
// RentalManager::reviewRental 方法实现
bool RentalManager::reviewRental(
    string rentalId, 
    string reviewerId, 
    bool approved, 
    string comment) {
    
    // 1. 查找租用记录
    Rental* rental = getRentalById(rentalId);
    if (rental == nullptr) {
        throw ResourceException(ERROR_RENTAL_NOT_FOUND, "租用记录不存在");
    }
    
    // 2. 检查租用状态
    if (rental->status != RentalStatus::PENDING) {
        throw ResourceException(ERROR_INVALID_RENTAL_STATUS, "只能审核处于申请中状态的租用");
    }
    
    // 3. 检查审核人权限
    User* reviewer = userManager.getUserById(reviewerId);
    if (reviewer == nullptr || 
        dynamic_cast<Administrator*>(reviewer) == nullptr) {
        throw UserException(ERROR_PERMISSION_DENIED, "只有管理员可以审核租用申请");
    }
    
    // 4. 获取资源和用户
    CloudResource* resource = resourceManager.getResourceById(rental->resourceId);
    User* user = userManager.getUserById(rental->userId);
    
    if (resource == nullptr || user == nullptr) {
        throw SystemException(ERROR_DATA_INCONSISTENCY, "系统数据不一致");
    }
    
    // 5. 更新租用状态
    time_t currentTime = time(nullptr);
    rental->reviewerId = reviewerId;
    rental->reviewTime = currentTime;
    rental->reviewComment = comment;
    
    if (approved) {
        // 审核通过
        rental->status = RentalStatus::APPROVED;
        
        // 设置开始和结束时间
        rental->startTime = currentTime;
        // 计算租用时长（小时）
        int hours = rental->calculateDuration();
        rental->endTime = currentTime + hours * 3600;  // 转换为秒
        
        // 更新资源状态
        resource->status = ResourceStatus::OCCUPIED;
        resourceManager.updateResource(resource);
        
        // 通知用户
        notificationService.addNotification(
            rental->userId,
            "您的租用申请已通过审核，资源ID: " + rental->resourceId + 
            "，开始时间: " + Utils::formatDateTime(rental->startTime) + 
            "，结束时间: " + Utils::formatDateTime(rental->endTime),
            1  // 中等优先级
        );
    } else {
        // 审核拒绝
        rental->status = RentalStatus::REJECTED;
        
        // 通知用户
        notificationService.addNotification(
            rental->userId,
            "您的租用申请被拒绝，资源ID: " + rental->resourceId + 
            "，拒绝原因: " + comment,
            2  // 高优先级
        );
    }
    
    // 6. 记录日志
    logManager.addLog("审核租用申请", reviewerId, 
        "租用ID: " + rentalId + ", 结果: " + (approved ? "通过" : "拒绝"));
    
    return true;
}
```

### 3. 租用完成算法

**功能描述**：处理租用完成流程，计算费用并释放资源。

```cpp
// RentalManager::completeRental 方法实现
bool RentalManager::completeRental(string rentalId) {
    // 1. 查找租用记录
    Rental* rental = getRentalById(rentalId);
    if (rental == nullptr) {
        throw ResourceException(ERROR_RENTAL_NOT_FOUND, "租用记录不存在");
    }
    
    // 2. 检查租用状态
    if (rental->status != RentalStatus::USING && 
        rental->status != RentalStatus::APPROVED) {
        throw ResourceException(ERROR_INVALID_RENTAL_STATUS, 
            "只能完成处于使用中或已批准状态的租用");
    }
    
    // 3. 获取资源和用户
    CloudResource* resource = resourceManager.getResourceById(rental->resourceId);
    User* user = userManager.getUserById(rental->userId);
    
    if (resource == nullptr || user == nullptr) {
        throw SystemException(ERROR_DATA_INCONSISTENCY, "系统数据不一致");
    }
    
    // 4. 计算实际使用时长
    time_t currentTime = time(nullptr);
    time_t actualEndTime = min(currentTime, rental->endTime);
    int actualHours = Utils::calculateHours(rental->startTime, actualEndTime);
    
    // 确保最小计费单位
    actualHours = max(actualHours, billingService.minBillingUnit);
    
    // 5. 计算实际费用
    double actualFee = resource->calculatePrice(actualHours);
    
    // 6. 更新租用记录
    rental->status = RentalStatus::COMPLETED;
    rental->endTime = actualEndTime;
    rental->fee = actualFee;
    
    // 7. 扣除用户余额
    if (!billingService.updateUserBalance(user, -actualFee)) {
        // 余额不足，记录异常但仍然完成租用
        logManager.addLog("余额不足", user->id, 
            "租用ID: " + rentalId + ", 费用: " + to_string(actualFee));
        
        notificationService.addNotification(
            user->id,
            "您的账户余额不足，无法支付租用费用: " + to_string(actualFee) + 
            "，请尽快充值",
            3  // 最高优先级
        );
    }
    
    // 8. 释放资源
    resource->status = ResourceStatus::AVAILABLE;
    resourceManager.updateResource(resource);
    
    // 9. 生成账单
    string bill = billingService.generateBill(*rental);
    
    // 10. 通知用户
    notificationService.addNotification(
        user->id,
        "您的租用已完成，资源ID: " + rental->resourceId + 
        "，实际使用时长: " + to_string(actualHours) + "小时，" +
        "费用: " + to_string(actualFee) + "\n" + bill,
        1  // 中等优先级
    );
    
    // 11. 记录日志
    logManager.addLog("完成租用", user->id, 
        "租用ID: " + rentalId + ", 使用时长: " + to_string(actualHours) + 
        "小时, 费用: " + to_string(actualFee));
    
    return true;
}
```

## 四、计费与支付模块关键算法

### 1. 费用计算算法

**功能描述**：根据资源类型、使用时长和计费规则计算费用。

```cpp
// BillingService::calculateFee 方法实现
double BillingService::calculateFee(Rental& rental, CloudResource& resource) {
    // 1. 获取租用时长
    int hours = rental.calculateDuration();
    
    // 2. 确保最小计费单位
    hours = max(hours, minBillingUnit);
    
    // 3. 根据资源类型计算基础费用
    double baseFee = resource.calculatePrice(hours);
    
    // 4. 应用计费规则调整
    string resourceType = resource.type;
    double adjustmentFactor = 1.0;
    
    // 从计费规则表中获取调整因子
    if (pricingRules.find(resourceType) != pricingRules.end()) {
        adjustmentFactor = pricingRules[resourceType];
    }
    
    // 5. 计算最终费用
    double finalFee = baseFee * adjustmentFactor;
    
    // 6. 应用时间段折扣（例如夜间折扣）
    time_t startTime = rental.startTime;
    struct tm* timeInfo = localtime(&startTime);
    int hour = timeInfo->tm_hour;
    
    // 夜间折扣（22:00-8:00）
    if (hour >= 22 || hour < 8) {
        finalFee *= 0.8;  // 夜间8折
    }
    
    // 7. 应用用户类型折扣
    User* user = userManager.getUserById(rental.userId);
    if (dynamic_cast<Student*>(user) != nullptr) {
        finalFee *= 0.9;  // 学生9折
    }
    
    return finalFee;
}
```

### 2. 账单生成算法

**功能描述**：根据租用记录生成详细账单，包括费用明细。

```cpp
// BillingService::generateBill 方法实现
string BillingService::generateBill(Rental& rental) {
    // 1. 获取相关数据
    User* user = userManager.getUserById(rental.userId);
    CloudResource* resource = resourceManager.getResourceById(rental.resourceId);
    
    if (user == nullptr || resource == nullptr) {
        throw SystemException(ERROR_DATA_INCONSISTENCY, "系统数据不一致");
    }
    
    // 2. 计算使用时长
    int hours = Utils::calculateHours(rental.startTime, rental.endTime);
    
    // 3. 构建账单头部
    stringstream bill;
    bill << "============= 租用账单 =============" << endl;
    bill << "账单ID: " << Utils::generateUniqueId() << endl;
    bill << "生成时间: " << Utils::formatDateTime(time(nullptr)) << endl;
    bill << "用户ID: " << user->id << endl;
    bill << "用户名: " << user->name << endl;
    bill << endl;
    
    // 4. 租用详情
    bill << "------------- 租用详情 -------------" << endl;
    bill << "租用ID: " << rental.rentalId << endl;
    bill << "资源ID: " << resource->resourceId << endl;
    bill << "资源名称: " << resource->name << endl;
    bill << "资源类型: " << resource->type << endl;
    bill << "开始时间: " << Utils::formatDateTime(rental.startTime) << endl;
    bill << "结束时间: " << Utils::formatDateTime(rental.endTime) << endl;
    bill << "使用时长: " << hours << "小时" << endl;
    bill << endl;
    
    // 5. 费用明细
    bill << "------------- 费用明细 -------------" << endl;
    
    // 根据资源类型显示不同的费用计算明细
    if (resource->type == "CPU") {
        CPUResource* cpuResource = dynamic_cast<CPUResource*>(resource);
        bill << "CPU核心数: " << cpuResource->cores << endl;
        bill << "CPU频率: " << cpuResource->frequency << "GHz" << endl;
        bill << "基础单价: " << resource->basePrice << "/核心/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << cpuResource->cores << " × " << hours 
             << " = " << resource->basePrice * cpuResource->cores * hours << endl;
    } else if (resource->type == "GPU") {
        GPUResource* gpuResource = dynamic_cast<GPUResource*>(resource);
        bill << "GPU型号: " << gpuResource->model << endl;
        bill << "显存大小: " << gpuResource->memory << "GB" << endl;
        bill << "基础单价: " << resource->basePrice << "/GB/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << gpuResource->memory << " × " << hours 
             << " = " << resource->basePrice * gpuResource->memory * hours << endl;
    } else {
        StorageResource* storageResource = dynamic_cast<StorageResource*>(resource);
        bill << "存储容量: " << storageResource->capacity << "GB" << endl;
        bill << "读写速度: " << storageResource->readWriteSpeed << "MB/s" << endl;
        bill << "基础单价: " << resource->basePrice << "/GB/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << storageResource->capacity << " × " << hours 
             << " = " << resource->basePrice * storageResource->capacity * hours << endl;
    }
    
    // 6. 折扣信息
    bill << endl << "------------- 折扣信息 -------------" << endl;
    
    double discountFactor = rental.fee / (resource->basePrice * hours);
    if (discountFactor < 1.0) {
        bill << "折扣系数: " << discountFactor << endl;
        bill << "折扣说明: ";
        
        // 根据用户类型和时间段判断折扣原因
        if (dynamic_cast<Student*>(user) != nullptr) {
            bill << "学生用户享受9折优惠" << endl;
        }
        
        struct tm* timeInfo = localtime(&rental.startTime);
        int hour = timeInfo->tm_hour;
        if (hour >= 22 || hour < 8) {
            bill << "夜间时段享受8折优惠" << endl;
        }
        
        if (hours > 72) {
            bill << "长时间使用享受额外折扣" << endl;
        }
    } else {
        bill << "无折扣" << endl;
    }
    
    // 7. 最终费用
    bill << endl << "------------- 最终费用 -------------" << endl;
    bill << "应付金额: " << rental.fee << endl;
    bill << "支付状态: 已从账户余额扣除" << endl;
    bill << "账户余额: " << user->getBalance() << endl;
    
    // 8. 账单尾部
    bill << "=====================================" << endl;
    bill << "感谢您使用云算力资源租用系统！" << endl;
    
    return bill.str();
}
```

### 3. 余额不足处理算法

**功能描述**：处理用户余额不足情况，确保系统正常运行。

```cpp
// BillingService::handleInsufficientBalance 方法实现
void BillingService::handleInsufficientBalance(User* user, double requiredAmount) {
    if (user == nullptr) {
        throw UserException(ERROR_USER_NOT_FOUND, "用户不存在");
    }
    
    double currentBalance = user->getBalance();
    double shortfall = requiredAmount - currentBalance;
    
    // 1. 记录日志
    logManager.addLog("余额不足", user->id, 
        "当前余额: " + to_string(currentBalance) + 
        ", 需要: " + to_string(requiredAmount) + 
        ", 差额: " + to_string(shortfall));
    
    // 2. 发送高优先级通知
    notificationService.addNotification(
        user->id,
        "您的账户余额不足，当前余额: " + to_string(currentBalance) + 
        "，需要: " + to_string(requiredAmount) + 
        "，请尽快充值以继续使用服务",
        3  // 最高优先级
    );
    
    // 3. 限制用户操作
    // 如果是学生用户，可以暂时允许小额透支
    if (dynamic_cast<Student*>(user) != nullptr && shortfall < 50) {
        // 允许小额透支，但记录欠款
        user->updateBalance(-currentBalance);  // 清空余额
        
        // 记录欠款信息
        // 实际实现中可能需要一个专门的欠款记录结构
        notificationService.addNotification(
            user->id,
            "系统已为您临时垫付" + to_string(shortfall) + 
            "元，请在3天内充值，否则将限制账户使用",
            2  // 高优先级
        );
        
        logManager.addLog("允许透支", user->id, 
            "透支金额: " + to_string(shortfall));
    } else {
        // 其他情况，暂停用户的新申请权限
        // 实际实现中可能需要修改用户状态或设置特殊标记
        notificationService.addNotification(
            user->id,
            "由于余额不足，您的新租用申请权限已被暂停，请充值后恢复使用",
            2  // 高优先级
        );
        
        // 设置用户状态为受限
        user->setLimitedStatus(true);
        userManager.updateUser(user);
        
        logManager.addLog("暂停权限", user->id, 
            "原因: 余额不足, 差额: " + to_string(shortfall));
    }
    
    // 4. 通知管理员
    vector<User*> admins = userManager.getAdministrators();
    for (auto admin : admins) {
        notificationService.addNotification(
            admin->id,
            "用户 " + user->name + " (ID: " + user->id + ") 余额不足，" +
            "当前余额: " + to_string(currentBalance) + 
            "，需要: " + to_string(requiredAmount),
            1  // 中等优先级
        );
    }
    
    // 5. 检查是否有正在进行的租用，如果有可能需要提前终止
    vector<Rental> activeRentals = rentalManager.getActiveRentalsByUserId(user->id);
    if (!activeRentals.empty()) {
        // 如果差额过大且有多个租用，可能需要终止部分租用
        if (shortfall > 100 && activeRentals.size() > 1) {
            // 按照租用剩余时间排序，优先保留剩余时间少的租用
            sort(activeRentals.begin(), activeRentals.end(), 
                [](const Rental& a, const Rental& b) {
                    return (a.endTime - time(nullptr)) < (b.endTime - time(nullptr));
                });
            
            // 尝试终止部分租用以减少费用
            for (size_t i = activeRentals.size() - 1; i > 0; i--) {
                // 通知用户租用将被终止
                notificationService.addNotification(
                    user->id,
                    "由于余额不足，您的租用 (ID: " + activeRentals[i].rentalId + 
                    ") 将被提前终止，请尽快保存您的工作",
                    3  // 最高优先级
                );
                
                // 设置一个宽限期（例如1小时）后终止租用
                time_t graceEndTime = time(nullptr) + 3600;  // 1小时后
                activeRentals[i].endTime = min(activeRentals[i].endTime, graceEndTime);
                rentalManager.updateRental(activeRentals[i]);
                
                logManager.addLog("提前终止租用", user->id, 
                    "租用ID: " + activeRentals[i].rentalId + 
                    ", 原因: 余额不足");
                
                // 如果终止一个租用后余额可能足够，则停止终止更多租用
                shortfall -= 50;  // 假设每个租用至少节省50元
                if (shortfall <= 0) break;
            }
        }
    }
}

    // 根据资源类型显示不同的费用计算明细
    if (resource->type == "CPU") {
        CPUResource* cpuResource = dynamic_cast<CPUResource*>(resource);
        bill << "CPU核心数: " << cpuResource->cores << endl;
        bill << "CPU频率: " << cpuResource->frequency << "GHz" << endl;
        bill << "基础单价: " << resource->basePrice << "/核心/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << cpuResource->cores << " × " << hours 
             << " = " << resource->basePrice * cpuResource->cores * hours << endl;
    } else if (resource->type == "GPU") {
        GPUResource* gpuResource = dynamic_cast<GPUResource*>(resource);
        bill << "GPU型号: " << gpuResource->model << endl;
        bill << "显存大小: " << gpuResource->memory << "GB" << endl;
        bill << "基础单价: " << resource->basePrice << "/GB/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << gpuResource->memory << " × " << hours 
             << " = " << resource->basePrice * gpuResource->memory * hours << endl;
    } else if (resource->type == "Storage") {
        StorageResource* storageResource = dynamic_cast<StorageResource*>(resource);
        bill << "存储容量: " << storageResource->capacity << "GB" << endl;
        bill << "读写速度: " << storageResource->readWriteSpeed << "MB/s" << endl;
        bill << "基础单价: " << resource->basePrice << "/GB/小时" << endl;
        bill << "基础费用: " << resource->basePrice << " × " 
             << storageResource->capacity << " × " << hours 
             << " = " << resource->basePrice * storageResource->capacity * hours << endl;
    }
    
    // 6. 折扣信息
    bill << endl << "------------- 折扣信息 -------------" << endl;
    
    // 长时间使用折扣
    double discountRate = 1.0;
    if (hours > 168) {
        bill << "长时间使用折扣(>168小时): 0.85" << endl;
        discountRate *= 0.85;
    } else if (hours > 72) {
        bill << "长时间使用折扣(>72小时): 0.9" << endl;
        discountRate *= 0.9;
    }
    
    // 用户类型折扣
    if (dynamic_cast<Student*>(user) != nullptr) {
        bill << "学生用户折扣: 0.9" << endl;
        discountRate *= 0.9;
    }
    
    // 时间段折扣
    struct tm* timeInfo = localtime(&rental.startTime);
    int hour = timeInfo->tm_hour;
    if (hour >= 22 || hour < 8) {
        bill << "夜间使用折扣(22:00-8:00): 0.8" << endl;
        discountRate *= 0.8;
    }
    
    // 7. 最终费用
    bill << endl << "------------- 最终费用 -------------" << endl;
    bill << "折扣前费用: " << rental.fee / discountRate << endl;
    bill << "折扣系数: " << discountRate << endl;
    bill << "最终费用: " << rental.fee << endl;
    
    // 8. 账单尾部
    bill << endl << "============= 账单结束 =============" << endl;
    bill << "感谢您使用云算力资源租用系统！" << endl;
    
    return bill.str();
}
```

### 4. 余额更新算法

**功能描述**：安全地更新用户余额，处理余额不足等异常情况。

```cpp
// BillingService::updateUserBalance 方法实现
bool BillingService::updateUserBalance(User* user, double amount) {
    // 1. 参数验证
    if (user == nullptr) {
        throw UserException(ERROR_USER_NOT_FOUND, "用户不存在");
    }
    
    // 2. 获取当前余额
    double currentBalance = user->getBalance();
    
    // 3. 检查余额是否足够（如果是扣款操作）
    if (amount < 0 && currentBalance + amount < 0) {
        // 余额不足
        return false;
    }
    
    // 4. 更新余额
    double newBalance = currentBalance + amount;
    user->updateBalance(newBalance);
    
    // 5. 记录交易日志
    string operation = amount > 0 ? "充值" : "扣款";
    logManager.addLog(operation, user->id, 
        "金额: " + to_string(abs(amount)) + 
        ", 更新前余额: " + to_string(currentBalance) + 
        ", 更新后余额: " + to_string(newBalance));
    
    // 6. 检查余额是否过低，发送通知
    if (newBalance < 10.0) {
        notificationService.addNotification(
            user->id,
            "您的账户余额较低，当前余额: " + to_string(newBalance) + 
            "，请及时充值以确保服务正常使用。",
            2  // 高优先级
        );
    }
    
    return true;
}
```

## 五、通知服务模块关键算法

### 1. 租用超时检查算法

**功能描述**：定期检查租用是否超时，自动处理超时租用并通知用户。

```cpp
// NotificationService::checkRentalTimeout 方法实现
void NotificationService::checkRentalTimeout() {
    // 1. 获取当前时间
    time_t currentTime = time(nullptr);
    
    // 2. 获取所有处于使用中的租用
    vector<Rental> activeRentals = rentalManager.getRentalsByStatus(RentalStatus::USING);
    
    // 3. 检查每个租用是否超时
    for (auto& rental : activeRentals) {
        // 如果当前时间超过了结束时间，则租用超时
        if (currentTime > rental.endTime) {
            // 4. 记录日志
            logManager.addLog("租用超时", rental.userId, 
                "租用ID: " + rental.rentalId + 
                ", 应结束时间: " + Utils::formatDateTime(rental.endTime));
            
            // 5. 通知用户
            notificationService.addNotification(
                rental.userId,
                "您的租用(ID: " + rental.rentalId + ")已超时，" +
                "系统将自动完成该租用并计费。",
                2  // 高优先级
            );
            
            // 6. 自动完成租用
            try {
                rentalManager.completeRental(rental.rentalId);
            } catch (Exception& e) {
                // 处理异常
                logManager.addLog("自动完成租用失败", rental.userId, 
                    "租用ID: " + rental.rentalId + 
                    ", 错误: " + e.getErrorMessage());
            }
        } else if (rental.endTime - currentTime < 3600) {
            // 7. 如果距离结束时间不足1小时，发送提醒
            notificationService.addNotification(
                rental.userId,
                "您的租用(ID: " + rental.rentalId + ")即将到期，" +
                "剩余时间不足1小时。如需继续使用，请及时申请延长租用时间。",
                1  // 中等优先级
            );
        }
    }
}
```

### 2. 通知优先级排序算法

**功能描述**：根据通知优先级和时间对用户通知进行排序，确保重要通知优先显示。

```cpp
// NotificationService::getNotifications 方法实现
vector<Notification> NotificationService::getNotifications(
    string userId, bool unreadOnly = false) {
    
    // 1. 筛选符合条件的通知
    vector<Notification> userNotifications;
    for (auto& notification : notifications) {
        if (notification.userId == userId && 
            (!unreadOnly || !notification.isRead)) {
            userNotifications.push_back(notification);
        }
    }
    
    // 2. 根据优先级和时间排序
    sort(userNotifications.begin(), userNotifications.end(), 
        [](const Notification& a, const Notification& b) {
            // 首先按优先级排序（高优先级在前）
            if (a.priority != b.priority) {
                return a.priority > b.priority;
            }
            // 其次按时间排序（新通知在前）
            return a.createTime > b.createTime;
        });
    
    return userNotifications;
}
```

## 六、数据持久化关键算法

### 1. 用户数据序列化与反序列化算法

**功能描述**：将用户对象序列化为二进制数据并保存到文件，或从文件读取二进制数据反序列化为用户对象。

```cpp
// UserManager::saveUsers 方法实现
void UserManager::saveUsers() {
    // 1. 打开文件
    ofstream file("users.dat", ios::binary);
    if (!file.is_open()) {
        throw SystemException(ERROR_FILE_OPEN_FAILED, "无法打开用户数据文件");
    }
    
    // 2. 写入用户数量
    int userCount = users.size();
    file.write(reinterpret_cast<char*>(&userCount), sizeof(userCount));
    
    // 3. 逐个序列化用户
    for (auto user : users) {
        // 3.1 写入用户类型
        int userType = 0;  // 0: Student, 1: Teacher, 2: Administrator
        if (dynamic_cast<Student*>(user) != nullptr) {
            userType = 0;
        } else if (dynamic_cast<Teacher*>(user) != nullptr) {
            userType = 1;
        } else if (dynamic_cast<Administrator*>(user) != nullptr) {
            userType = 2;
        }
        file.write(reinterpret_cast<char*>(&userType), sizeof(userType));
        
        // 3.2 写入基本属性
        // 写入ID长度和ID内容
        int idLength = user->id.length();
        file.write(reinterpret_cast<char*>(&idLength), sizeof(idLength));
        file.write(user->id.c_str(), idLength);
        
        // 写入姓名长度和姓名内容
        int nameLength = user->name.length();
        file.write(reinterpret_cast<char*>(&nameLength), sizeof(nameLength));
        file.write(user->name.c_str(), nameLength);
        
        // 写入密码长度和密码内容
        int passwordLength = user->password.length();
        file.write(reinterpret_cast<char*>(&passwordLength), sizeof(passwordLength));
        file.write(user->password.c_str(), passwordLength);
        
        // 写入余额
        file.write(reinterpret_cast<char*>(&user->balance), sizeof(user->balance));
        
        // 写入注册时间
        file.write(reinterpret_cast<char*>(&user->registerTime), sizeof(user->registerTime));
        
        // 写入用户状态
        int status = static_cast<int>(user->status);
        file.write(reinterpret_cast<char*>(&status), sizeof(status));
        
        // 3.3 根据用户类型写入特定属性
        if (userType == 0) {  // Student
            Student* student = dynamic_cast<Student*>(user);
            
            // 写入学号长度和学号内容
            int studentIdLength = student->studentId.length();
            file.write(reinterpret_cast<char*>(&studentIdLength), sizeof(studentIdLength));
            file.write(student->studentId.c_str(), studentIdLength);
            
            // 写入班级长度和班级内容
            int classNameLength = student->className.length();
            file.write(reinterpret_cast<char*>(&classNameLength), sizeof(classNameLength));
            file.write(student->className.c_str(), classNameLength);
            
            // 写入最大配额
            file.write(reinterpret_cast<char*>(&student->maxQuota), sizeof(student->maxQuota));
        } else if (userType == 1) {  // Teacher
            Teacher* teacher = dynamic_cast<Teacher*>(user);
            
            // 写入工号长度和工号内容
            int employeeIdLength = teacher->employeeId.length();
            file.write(reinterpret_cast<char*>(&employeeIdLength), sizeof(employeeIdLength));
            file.write(teacher->employeeId.c_str(), employeeIdLength);
            
            // 写入部门长度和部门内容
            int departmentLength = teacher->department.length();
            file.write(reinterpret_cast<char*>(&departmentLength), sizeof(departmentLength));
            file.write(teacher->department.c_str(), departmentLength);
            
            // 写入最大配额
            file.write(reinterpret_cast<char*>(&teacher->maxQuota), sizeof(teacher->maxQuota));
        } else if (userType == 2) {  // Administrator
            Administrator* admin = dynamic_cast<Administrator*>(user);
            
            // 写入权限等级
            file.write(reinterpret_cast<char*>(&admin->permissionLevel), sizeof(admin->permissionLevel));
        }
    }
    
    // 4. 关闭文件
    file.close();
}

// UserManager::loadUsers 方法实现
void UserManager::loadUsers() {
    // 1. 清空现有用户列表
    for (auto user : users) {
        delete user;
    }
    users.clear();
    
    // 2. 打开文件
    ifstream file("users.dat", ios::binary);
    if (!file.is_open()) {
        // 文件不存在，可能是首次运行，不抛出异常
        return;
    }
    
    // 3. 读取用户数量
    int userCount;
    file.read(reinterpret_cast<char*>(&userCount), sizeof(userCount));
    
    // 4. 逐个反序列化用户
    for (int i = 0; i < userCount; i++) {
        // 4.1 读取用户类型
        int userType;
        file.read(reinterpret_cast<char*>(&userType), sizeof(userType));
        
        // 4.2 读取基本属性
        // 读取ID
        int idLength;
        file.read(reinterpret_cast<char*>(&idLength), sizeof(idLength));
        char* idBuffer = new char[idLength + 1];
        file.read(idBuffer, idLength);
        idBuffer[idLength] = '\0';
        string id(idBuffer);
        delete[] idBuffer;
        
        // 读取姓名
        int nameLength;
        file.read(reinterpret_cast<char*>(&nameLength), sizeof(nameLength));
        char* nameBuffer = new char[nameLength + 1];
        file.read(nameBuffer, nameLength);
        nameBuffer[nameLength] = '\0';
        string name(nameBuffer);
        delete[] nameBuffer;
        
        // 读取密码
        int passwordLength;
        file.read(reinterpret_cast<char*>(&passwordLength), sizeof(passwordLength));
        char* passwordBuffer = new char[passwordLength + 1];
        file.read(passwordBuffer, passwordLength);
        passwordBuffer[passwordLength] = '\0';
        string password(passwordBuffer);
        delete[] passwordBuffer;
        
        // 读取余额
        double balance;
        file.read(reinterpret_cast<char*>(&balance), sizeof(balance));
        
        // 读取注册时间
        time_t registerTime;
        file.read(reinterpret_cast<char*>(&registerTime), sizeof(registerTime));
        
        // 读取用户状态
        int status;
        file.read(reinterpret_cast<char*>(&status), sizeof(status));
        UserStatus userStatus = static_cast<UserStatus>(status);
        
        // 4.3 根据用户类型创建对象并读取特定属性
        User* user = nullptr;
        
        if (userType == 0) {  // Student
            // 读取学号
            int studentIdLength;
            file.read(reinterpret_cast<char*>(&studentIdLength), sizeof(studentIdLength));
            char* studentIdBuffer = new char[studentIdLength + 1];
            file.read(studentIdBuffer, studentIdLength);
            studentIdBuffer[studentIdLength] = '\0';
            string studentId(studentIdBuffer);
            delete[] studentIdBuffer;
            
            // 读取班级
            int classNameLength;
            file.read(reinterpret_cast<char*>(&classNameLength), sizeof(classNameLength));
            char* classNameBuffer = new char[classNameLength + 1];
            file.read(classNameBuffer, classNameLength);
            classNameBuffer[classNameLength] = '\0';
            string className(classNameBuffer);
            delete[] classNameBuffer;
            
            // 读取最大配额
            int maxQuota;
            file.read(reinterpret_cast<char*>(&maxQuota), sizeof(maxQuota));
            
            // 创建学生对象
            Student* student = new Student();
            student->id = id;
            student->name = name;
            student->password = password;
            student->balance = balance;
            student->registerTime = registerTime;
            student->status = userStatus;
            student->studentId = studentId;
            student->className = className;
            student->maxQuota = maxQuota;
            
            user = student;
        } else if (userType == 1) {  // Teacher
            // 读取工号
            int employeeIdLength;
            file.read(reinterpret_cast<char*>(&employeeIdLength), sizeof(employeeIdLength));
            char* employeeIdBuffer = new char[employeeIdLength + 1];
            file.read(employeeIdBuffer, employeeIdLength);
            employeeIdBuffer[employeeIdLength] = '\0';
            string employeeId(employeeIdBuffer);
            delete[] employeeIdBuffer;
            
            // 读取部门
            int departmentLength;
            file.read(reinterpret_cast<char*>(&departmentLength), sizeof(departmentLength));
            char* departmentBuffer = new char[departmentLength + 1];
            file.read(departmentBuffer, departmentLength);
            departmentBuffer[departmentLength] = '\0';
            string department(departmentBuffer);
            delete[] departmentBuffer;
            
            // 读取最大配额
            int maxQuota;
            file.read(reinterpret_cast<char*>(&maxQuota), sizeof(maxQuota));
            
            // 创建教师对象
            Teacher* teacher = new Teacher();
            teacher->id = id;
            teacher->name = name;
            teacher->password = password;
            teacher->balance = balance;
            teacher->registerTime = registerTime;
            teacher->status = userStatus;
            teacher->employeeId = employeeId;
            teacher->department = department;
            teacher->maxQuota = maxQuota;
            
            user = teacher;
        } else if (userType == 2) {  // Administrator
            // 读取权限等级
            int permissionLevel;
            file.read(reinterpret_cast<char*>(&permissionLevel), sizeof(permissionLevel));
            
            // 创建管理员对象
            Administrator* admin = new Administrator();
            admin->id = id;
            admin->name = name;
            admin->password = password;
            admin->balance = balance;
            admin->registerTime = registerTime;
            admin->status = userStatus;
            admin->permissionLevel = permissionLevel;
            
            user = admin;
        }
        
        // 4.4 将用户添加到列表
        if (user != nullptr) {
            users.push_back(user);
        }
    }
    
    // 5. 关闭文件
    file.close();
}
```

## 七、异常处理关键算法

### 1. 异常捕获与处理算法

**功能描述**：捕获并处理系统中的各类异常，确保系统稳定运行。

```cpp
// SystemManager::run 方法实现中的异常处理部分
void SystemManager::run() {
    // 初始化系统
    try {
        initialize();
    } catch (SystemException& e) {
        cout << "系统初始化失败: " << e.getErrorMessage() << endl;
        return;
    }
    
    // 主循环
    bool running = true;
    while (running) {
        try {
            // 显示主菜单
            Menu::showMainMenu();
            
            // 获取用户选择
            int choice;
            cin >> choice;
            
            // 处理用户选择
            switch (choice) {
                case 1: // 登录
                    handleLogin();
                    break;
                case 2: // 注册
                    handleRegister();
                    break;
                case 0: // 退出
                    running = false;
                    break;
                default:
                    cout << "无效选择，请重试" << endl;
                    break;
            }
        } catch (UserException& e) {
            // 处理用户相关异常
            cout << "用户操作异常: " << e.getErrorMessage() << endl;
            logManager.addLog("用户异常", "system", e.getErrorMessage());
        } catch (ResourceException& e) {
            // 处理资源相关异常
            cout << "资源操作异常: " << e.getErrorMessage() << endl;
            logManager.addLog("资源异常", "system", e.getErrorMessage());
        } catch (SystemException& e) {
            // 处理系统相关异常
            cout << "系统异常: " << e.getErrorMessage() << endl;
            logManager.addLog("系统异常", "system", e.getErrorMessage());
            
            // 尝试恢复
            try {
                recoverFromSystemException(e);
            } catch (Exception& recoverException) {
                cout << "系统无法恢复，即将退出: " << recoverException.getErrorMessage() << endl;
                running = false;
            }
        } catch (exception& e) {
            // 处理标准库异常
            cout << "未知异常: " << e.what() << endl;
            logManager.addLog("未知异常", "system", e.what());
        } catch (...) {
            // 处理其他未知异常
            cout << "发生未知异常，系统将尝试继续运行" << endl;
            logManager.addLog("未捕获异常", "system", "未知异常类型");
        }
    }
    
    // 保存数据并关闭系统
    try {
        shutdown();
    } catch (SystemException& e) {
        cout << "系统关闭时发生异常: " << e.getErrorMessage() << endl;
        logManager.addLog("关闭异常", "system", e.getErrorMessage());
    }
}
```

### 2. 系统恢复算法

**功能描述**：从系统异常中恢复，尝试保护数据并恢复正常运行。

```cpp
// SystemManager::recoverFromSystemException 方法实现
void SystemManager::recoverFromSystemException(SystemException& e) {
    // 1. 记录恢复尝试
    logManager.addLog("恢复尝试", "system", 
        "错误代码: " + to_string(e.getErrorCode()) + 
        ", 错误信息: " + e.getErrorMessage());
    
    // 2. 根据异常类型进行恢复
    switch (e.getErrorCode()) {
        case ERROR_FILE_OPEN_FAILED:
            // 文件打开失败，尝试创建新文件
            handleFileOpenFailure();
            break;
            
        case ERROR_DATA_INCONSISTENCY:
            // 数据不一致，尝试修复
            handleDataInconsistency();
            break;
            
        case ERROR_MEMORY_ALLOCATION:
            // 内存分配失败，尝试释放内存
            handleMemoryAllocationFailure();
            break;
            
        default:
            // 其他系统异常，尝试通用恢复
            // 1. 保存当前数据
            saveAllData();
            
            // 2. 重新加载数据
            loadAllData();
            break;
    }
    
    // 3. 记录恢复结果
    logManager.addLog("恢复完成", "system", 
        "已尝试从错误代码 " + to_string(e.getErrorCode()) + " 恢复");
}

// 处理文件打开失败
void SystemManager::handleFileOpenFailure() {
    // 1. 检查文件路径
    string dataPath = "./";  // 默认数据路径
    
    // 2. 尝试创建数据目录
    system(("mkdir " + dataPath).c_str());
    
    // 3. 尝试创建空文件
    ofstream usersFile(dataPath + "users.dat", ios::binary);
    if (usersFile.is_open()) {
        usersFile.close();
    }
    
    ofstream resourcesFile(dataPath + "resources.dat", ios::binary);
    if (resourcesFile.is_open()) {
        resourcesFile.close();
    }
    
    ofstream rentalsFile(dataPath + "rentals.dat", ios::binary);
    if (rentalsFile.is_open()) {
        rentalsFile.close();
    }
    
    ofstream logsFile(dataPath + "logs.dat", ios::binary);
    if (logsFile.is_open()) {
        logsFile.close();
    }
    
    // 4. 尝试从备份恢复
    tryRestoreFromBackup();
}

// 处理数据不一致
void SystemManager::handleDataInconsistency() {
    // 1. 记录不一致状态
    logManager.addLog("数据不一致", "system", "尝试修复数据不一致");
    
    // 2. 验证用户-租用关系
    validateUserRentalRelationship();
    
    // 3. 验证资源-租用关系
    validateResourceRentalRelationship();
    
    // 4. 重新计算所有租用费用
    recalculateAllRentalFees();
}

// 处理内存分配失败
void SystemManager::handleMemoryAllocationFailure() {
    // 1. 尝试释放非关键内存
    clearCaches();
    
    // 2. 减少批处理大小
    reduceBatchSize();
    
    // 3. 如果仍然失败，保存数据并建议重启
    saveAllData();
    cout << "系统内存不足，建议重启应用程序" << endl;
}
```

## 八、工具类关键算法

### 1. 唯一ID生成算法

**功能描述**：生成全局唯一的ID，用于标识用户、资源、租用记录等。

```cpp
// Utils::generateUniqueId 方法实现
string Utils::generateUniqueId() {
    // 1. 获取当前时间戳（毫秒级）
    auto now = chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    auto millis = chrono::duration_cast<chrono::milliseconds>(duration).count();
    
    // 2. 获取随机数
    static random_device rd;
    static mt19937 gen(rd());
    static uniform_int_distribution<> dis(0, 999999);
    int random = dis(gen);
    
    // 3. 获取进程ID
    int pid = getpid();
    
    // 4. 组合生成唯一ID
    stringstream ss;
    ss << hex << millis << "-" << hex << random << "-" << hex << pid;
    
    // 5. 转换为大写
    string id = ss.str();
    transform(id.begin(), id.end(), id.begin(), ::toupper);
    
    return id;
}
```

### 2. 时间计算算法

**功能描述**：计算两个时间点之间的小时数，用于租用时长和费用计算。

```cpp
// Utils::calculateHours 方法实现
int Utils::calculateHours(time_t start, time_t end) {
    // 1. 参数验证
    if (start > end) {
        return 0;  // 开始时间晚于结束时间，返回0
    }
    
    // 2. 计算时间差（秒）
    double diffSeconds = difftime(end, start);
    
    // 3. 转换为小时并向上取整
    int hours = static_cast<int>(ceil(diffSeconds / 3600.0));
    
    return hours;
}
```


